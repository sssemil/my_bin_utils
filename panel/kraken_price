#!/bin/bash
# Usage: kraken_price <PAIR>
# Examples: BTCUSD, ETHUSD, XMRUSD, SOLUSD
# Debug: KRAKEN_DEBUG=1 kraken_price SOLUSD

set -o pipefail
LC_ALL=C

RETRIES=2
SLEEP_BETWEEN=0.6

log_debug() { [[ -n "$KRAKEN_DEBUG" ]] && echo "DBG: $*" >&2; }

is_number() {
  [[ "$1" =~ ^-?[0-9]+([.][0-9]+)?$ ]]
}

round_to_k_or_m() {
  local value="$1"
  if ! is_number "$value"; then
    printf "%s" "$value"; return
  fi
  local abs_value="${value#-}"
  local int_value; int_value=$(printf "%.0f" "$abs_value" 2>/dev/null)
  if (( int_value >= 1000000 )); then
    printf "%.2fm" "$(bc -l <<< "$value / 1000000")"
  elif (( int_value >= 1000 )); then
    printf "%.2fk" "$(bc -l <<< "$value / 1000")"
  else
    printf "%.2f" "$value"
  fi
}

fetch_json() {
  # $1: URL
  local attempt=0
  local resp
  while :; do
    resp=$(curl -sS --fail --compressed --max-time 15 "$1") && { echo "$resp"; return 0; }
    (( attempt++ >= RETRIES )) && return 1
    sleep "$SLEEP_BETWEEN"
  done
}

# jq selector that **only** picks the candle array (ignores "last" and any non-array values)
# Produces the array of candles for the requested pair.
jq_candles='.result
  | to_entries[]
  | select(.key != "last" and (.value | type) == "array")
  | .value'

get_current_price() {
  local pair="$1" response price errlen
  response=$(fetch_json "https://api.kraken.com/0/public/OHLC?pair=${pair}&interval=15") || {
    echo "Error: network/API failure for $pair" >&2; return 1; }
  errlen=$(jq -r '.error | length' <<<"$response")
  if [[ "$errlen" != "0" ]]; then
    echo "Error: Kraken returned error(s) for $pair: $(jq -r '.error | join("; ")' <<<"$response")" >&2
    return 1
  fi
  # Newest candle close
  price=$(jq -r "${jq_candles} | .[-1][4]" <<<"$response")
  log_debug "current(15m) raw: $price"
  if ! is_number "$price"; then
    echo "Error: Invalid price data for $pair" >&2; return 1
  fi
  printf "%s" "$price"
}

get_hourly_prices() {
  local pair="$1" response current price24 errlen
  response=$(fetch_json "https://api.kraken.com/0/public/OHLC?pair=${pair}&interval=60") || {
    echo "Error: network/API failure for $pair" >&2; return 1; }
  errlen=$(jq -r '.error | length' <<<"$response")
  if [[ "$errlen" != "0" ]]; then
    echo "Error: Kraken returned error(s) for $pair: $(jq -r '.error | join("; ")' <<<"$response")" >&2
    return 1
  fi
  # Current hour close
  current=$(jq -r "${jq_candles} | .[-1][4]" <<<"$response")
  # 7 days ago close; if not enough candles, fall back to first
  price24=$(jq -r "${jq_candles} | (.[-169][4] // .[0][4])" <<<"$response")
  log_debug "hourly current: $current ; 7d_ago: $price24"
  if ! is_number "$current" || ! is_number "$price24"; then
    echo "Error: Invalid hourly price data for $pair" >&2; return 1
  fi
  printf "%s %s" "$current" "$price24"
}

display_one_line() {
  local pair="$1" symbol="$2"
  local current_15 current_hour price_24h_ago change formatted

  if ! current_15=$(get_current_price "$pair"); then
    echo "Error: Unable to fetch current price for $pair" >&2; return 1
  fi
  local hourly_output
  if ! hourly_output=$(get_hourly_prices "$pair"); then
    echo "Error: Unable to fetch hourly prices for $pair" >&2; return 1
  fi
  read -r current_hour price_24h_ago <<< "$hourly_output"

  if [[ "$price_24h_ago" == "0" ]]; then
    change="0.00"
  else
    change=$(bc -l <<< "scale=6; 100 * ($current_hour - $price_24h_ago) / $price_24h_ago")
    change=$(printf "%.2f" "$change")
  fi

  formatted=$(round_to_k_or_m "$current_hour")
  printf "%s[%s%%]\$/%s%%\n" "$formatted" "$change" "$symbol"
}

declare -A SYMBOLS=(
  ["BTCUSD"]="₿"
  ["ETHUSD"]="Ξ"
  ["XMRUSD"]="ɱ"
  ["SOLUSD"]="◎"
)

PAIR="$1"
if [[ -z "${PAIR:-}" ]]; then
  echo "Usage: $0 <PAIR>"
  echo "Examples: BTCUSD, ETHUSD, XMRUSD, SOLUSD"
  exit 1
fi

SYMBOL="${SYMBOLS[$PAIR]:-$PAIR}"
display_one_line "$PAIR" "$SYMBOL"

